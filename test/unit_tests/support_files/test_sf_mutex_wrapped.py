"""
Testsuite validating the output of generated support file: Mutex Wrapped.

Copyright (c) 2023-2024 Michael van de Ven <michael@ftr-ict.com>
This is free software, released under the MIT License. Refer to dznpy/LICENSE.
"""

# system modules
import pytest

# dznpy modules
from dznpy.scoping import ns_ids_t, NamespaceIds

# systems-under-test
from dznpy.support_files import mutex_wrapped as sut

# Test data
from common.testdata import *
from dznpy.dznpy_version import VERSION


def template_hh(ns_prefix: str) -> str:
    return """\
// Mutex Wrapped helper
//
// Description: A simple concurrent thread safe wrapper to protect a shared resouce of type T.
//              Locking and accessing protected data is done with the Operator() method.
//              Releasing the lock can be done manually or automatically when the given lock goes
//              out of scope (RAII pattern).
//
// Tip: MutexWrap a struct containing multiple members to protect them as a whole. Considered they
//      cohesively are 'atomic'. Instead of having separate locks that potentially can yield
//      deadlocks when concurrent threads incrementally try to acquire them.
//
//
// Example:
//
// given """ f'{ns_prefix}' """Dzn::MutexWrapped<int> m_threadSafeNumber;
//
// {
//    auto lockAndData = m_threadSafeNumber(); // lock and access the data with Operator()
//    *lockAndData = 123; // by dereferencing, change value of the protected data
//
//    lockAndData.reset(); // release lock manually, or,
//                         // let it go out of scope for automatic RAII release of the lock.
// }
//
//
// This is generated content. DO NOT MODIFY manually.
//
// Copyright (c) 2023-2024 Michael van de Ven <michael@ftr-ict.com>
// This is free software, released under the MIT License. Refer to dznpy/LICENSE.

// System includes
#include <memory>
#include <mutex>

namespace """ f'{ns_prefix}' """Dzn {

template <typename T>
struct MutexWrapped
{
    // Get access to the protected data. May have to wait on a concurrent claiming thread to unlock
    // it first. When lock has been acquired, the client is given a unique_ptr to the data.
    //
    // Releasing the lock can be achieved as follows:
    // - by either explicitly resetting the unique_ptr, or,
    // - implicitly and guaranteed when the unique_ptr goes out of scope (calls RaiiLockDeleter)
    auto operator()( )
    {
        std::unique_lock lock(m_mutex);
        return std::unique_ptr<T, RaiiLockDeleter>(&m_protectee, RaiiLockDeleter{std::move(lock)});
    }

private:
    T m_protectee;      // default construct typename T
    std::mutex m_mutex; // the mutex coupled to the protectee

    struct RaiiLockDeleter // automatic mechanism to ensure releasing the lock a la RAII
    {
        std::unique_lock<std::mutex> lock;
        void operator()(T*) { if (lock.owns_lock()) lock.unlock(); }
    };
};

} // namespace """ f'{ns_prefix}' """Dzn
// Generated by: dznpy/support_files v"""f'{VERSION}'"""
"""


DEFAULT_DZN_NS_HH = template_hh('')
PROJ_DZN_NS_HH = template_hh('Proj::')


def test_create_default_namespaced():
    result = sut.create_header()
    assert result.namespace == ns_ids_t('Dzn')
    assert result.filename == 'Dzn_MutexWrapped.hh'
    assert result.contents == DEFAULT_DZN_NS_HH
    assert 'namespace Dzn {' in result.contents


def test_create_with_prefixing_namespace():
    result = sut.create_header(ns_ids_t('Proj'))
    assert result.namespace == NamespaceIds(['Proj', 'Dzn'])
    assert result.filename == 'Proj_Dzn_MutexWrapped.hh'
    assert result.contents == PROJ_DZN_NS_HH
    assert 'namespace Proj::Dzn {' in result.contents


def test_create_fail():
    with pytest.raises(TypeError) as exc:
        sut.create_header(123)
    assert str(exc.value) == ARGUMENT123_NOT_NAMESPACEIDS
