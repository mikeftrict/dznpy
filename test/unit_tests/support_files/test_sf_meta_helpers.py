"""
Testsuite validating the output of generated support file: MetaHelpers.

Copyright (c) 2023-2024 Michael van de Ven <michael@ftr-ict.com>
This is free software, released under the MIT License. Refer to dznpy/LICENSE.
"""

# system modules
import pytest

# dznpy modules
from dznpy.scoping import namespaceids_t

# systems-under-test
from dznpy.support_files import meta_helpers as sut

# Test data
from dznpy.dznpy_version import VERSION


def template_hh(ns_prefix: str) -> str:
    return """\
// Dezyne Meta helpers
//
// Description: helper functions for creating Dezyne Port meta
//
// Contents:
// - functions to create a Dezyne port where the name (provided, required, or both) are filled in,
//
// Examples:
//
// given a Dezyne port IMyService:
//
//     IMyService port = """ f'{ns_prefix}' """Dzn::CreateProvidedPort<IMyService>("api");
//
//     IMyService port = """ f'{ns_prefix}' """Dzn::CreateRequiredPort<IMyService>("hal");
//
//     IMyService port = """ f'{ns_prefix}' """Dzn::CreatePort<IMyService>("api", "hal");
//
//
// This is generated code. DO NOT MODIFY manually.
//
// Copyright (c) 2023-2024 Michael van de Ven <michael@ftr-ict.com>
// This is free software, released under the MIT License. Refer to dznpy/LICENSE.

// System includes
#include <string>
#include <dzn/meta.hh>

namespace """ f'{ns_prefix}' """Dzn {

template <typename DZN_PORT>
DZN_PORT CreateProvidedPort(const std::string& name)
{
    return DZN_PORT{{{name, nullptr, nullptr, nullptr}, {"", nullptr, nullptr, nullptr}}};
}

template <typename DZN_PORT>
DZN_PORT CreateRequiredPort(const std::string& name)
{
    return DZN_PORT{{{"", nullptr, nullptr, nullptr}, {name, nullptr, nullptr, nullptr}}};
}

template <typename DZN_PORT>
DZN_PORT CreatePort(const std::string& provideName, const std::string& requireName)
{
    return DZN_PORT{{{provideName, nullptr, nullptr, nullptr}, {requireName, nullptr, nullptr, nullptr}}};
}

} // namespace """ f'{ns_prefix}' """Dzn
// Generated by: dznpy/support_files v"""f'{VERSION}'"""
"""


DEFAULT_DZN_NS_HH = template_hh('')
MYPRODUCT_DZN_NS_HH = template_hh('My::Product::')


def test_create_default_namespaced():
    result = sut.create_header()
    assert result.namespace == ['Dzn']
    assert result.filename == 'Dzn_MetaHelpers.hh'
    assert result.contents == DEFAULT_DZN_NS_HH
    assert result.contents_hash == '15f103998473ee0aaa2c97c06509d196'
    assert 'namespace Dzn {' in result.contents


def test_create_with_prefixing_namespace():
    result = sut.create_header(namespaceids_t('My.Product'))
    assert result.namespace == ['My', 'Product', 'Dzn']
    assert result.filename == 'My_Product_Dzn_MetaHelpers.hh'
    assert result.contents == MYPRODUCT_DZN_NS_HH
    assert 'namespace My::Product::Dzn {' in result.contents


def test_create_fail():
    with pytest.raises(TypeError) as exc:
        sut.create_header(123)
    assert str(exc.value) == 'namespace_prefix is of incorrect type'
