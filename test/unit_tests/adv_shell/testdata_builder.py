"""
Test data for validating the generated output by the adv_shell module.

Copyright (c) Michael van de Ven <michael@ftr-ict.com>
This is free software, released under the MIT License. Refer to dznpy/LICENSE.
"""

# test data/contents from test/dezyne_models/
TOASTER_SYSTEM_JSON_FILE = 'generated/ToasterSystem.json'
STONE_AGE_TOASTER_FILE = 'generated/StoneAgeToaster.json'
EXCLUSIVE_TOASTER_JSON_FILE = 'generated/ExclusiveToaster.json'
DUMMY_EXCLUSIVE_TOASTER_JSON_FILE = 'generated/DummyExclusiveToaster.json'
DUMMY_COMPONENT_JSON_FILE = 'generated/DummyToaster.json'

CREATOR_INFO = '''\
ABC
DEF
GHI
'''

HH_ALL_STS_ALL_MTS = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// Creator information:
// <none>
//
// User configuration:
// - Encapsulee FQN: My.Project.ToasterSystem
// - Source file basename: ToasterSystem
// - Target file basename: ToasterSystemAdvShell
// - Dezyne facilities: Import facilities (by reference) from the user provided dzn::locator argument
// - Ports (none multiclient):
//     > provides ports: All STS
//     > requires ports: All MTS
//
// Final configuration:
// - Provides ports (Single-threaded):
//     > api: IToaster
//
// - Requires ports (Multi-threaded):
//     > heaterElement: IHeaterElement
//     > cord: IPowerCord
//     > led: ILed
//
// This is generated content. DO NOT MODIFY manually.

// System includes
#include <dzn/locator.hh>
#include <dzn/pump.hh>
// Project includes
#include "ToasterSystem.hh"
#include "Dzn_StrictPort.hh"

namespace My::Project {
struct ToasterSystemAdvShell
{
    ToasterSystemAdvShell(const dzn::locator& locator, const std::string& encapsuleeInstanceName = "");
    void FinalConstruct(const dzn::meta* parentComponentMeta = nullptr);

    // Facility accessor
    // <none>

    // Provides port accessor
    ::Dzn::Sts<::My::Project::IToaster> ProvidesApi();

    // Requires port accessors
    ::Dzn::Mts<::Some::Vendor::IHeaterElement> RequiresHeaterElement();
    ::Dzn::Mts<::My::Project::Hal::IPowerCord> RequiresCord();
    ::Dzn::Mts<::My::ILed> RequiresLed();

private:
    // Facilities
    dzn::pump& m_dispatcher;
    static const dzn::locator& FacilitiesCheck(const dzn::locator& locator);

    // The encapsulated component "ToasterSystem"
    ::My::Project::ToasterSystem m_encapsulee;

    // Boundary provides-port (MTS) to reroute inwards events
    // <none>

    // Boundary requires-ports (MTS) to reroute inwards events
    ::Some::Vendor::IHeaterElement m_rpHeaterElement;
    ::My::Project::Hal::IPowerCord m_rpCord;
    ::My::ILed m_rpLed;
};
} // namespace My::Project
// Generated by: dznpy/adv_shell v1.2.DEV
'''

CC_ALL_STS_ALL_MTS = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// This is generated content. DO NOT MODIFY manually.

// System include
#include <dzn/runtime.hh>
// Project include
#include "ToasterSystemAdvShell.hh"

namespace My::Project {

const dzn::locator& ToasterSystemAdvShell::FacilitiesCheck(const dzn::locator& locator)
{
    // This class imports the required facilities that must be provided by the user via the locator argument.

    if (locator.try_get<dzn::pump>() == nullptr) throw std::runtime_error("ToasterSystemAdvShell: Dispatcher missing (dzn::pump)");
    if (locator.try_get<dzn::runtime>() == nullptr) throw std::runtime_error("ToasterSystemAdvShell: Dezyne runtime missing (dzn::runtime)");

    return locator;
}

ToasterSystemAdvShell::ToasterSystemAdvShell(const dzn::locator& locator, const std::string& encapsuleeInstanceName)
    : m_dispatcher(FacilitiesCheck(locator).get<dzn::pump>())
    , m_encapsulee(locator)
    , m_rpHeaterElement(m_encapsulee.heaterElement)
    , m_rpCord(m_encapsulee.cord)
    , m_rpLed(m_encapsulee.led)
{
    // Complete the component meta info of the encapsulee and its ports that are configured for MTS
    m_encapsulee.dzn_meta.name = encapsuleeInstanceName;
    m_encapsulee.heaterElement.meta.provide.name = "heaterElement";
    m_encapsulee.cord.meta.provide.name = "cord";
    m_encapsulee.led.meta.provide.name = "led";

    // Boundary provides ports (MTS) initialization:
    // ---------------------------------------------

    // <None>

    // Boundary requires ports (MTS) initialization:
    // ---------------------------------------------

    // Reroute out-events of boundary requires ports (MTS) via the dispatcher
    m_rpCord.out.Connected = [&] {
        return m_dispatcher([&] { return m_encapsulee.cord.out.Connected(); });
    };
    m_rpCord.out.Disconnected = [&](My::Project::Hal::Sub::MyLongNamedType exampleParameter) {
        return m_dispatcher([&, exampleParameter] { return m_encapsulee.cord.out.Disconnected(exampleParameter); });
    };
    m_rpLed.out.GlitchOccurred = [&] {
        return m_dispatcher([&] { return m_encapsulee.led.out.GlitchOccurred(); });
    };

    // Reference in-events of boundary requires ports (MTS) to the respective ports of the encapsulee
    m_encapsulee.heaterElement.in.Initialize = std::ref(m_rpHeaterElement.in.Initialize);
    m_encapsulee.heaterElement.in.Uninitialize = std::ref(m_rpHeaterElement.in.Uninitialize);
    m_encapsulee.heaterElement.in.On = std::ref(m_rpHeaterElement.in.On);
    m_encapsulee.heaterElement.in.Off = std::ref(m_rpHeaterElement.in.Off);
    m_encapsulee.cord.in.Initialize = std::ref(m_rpCord.in.Initialize);
    m_encapsulee.cord.in.Uninitialize = std::ref(m_rpCord.in.Uninitialize);
    m_encapsulee.cord.in.IsConnectedToOutlet = std::ref(m_rpCord.in.IsConnectedToOutlet);
    m_encapsulee.cord.in.GetVoltage = std::ref(m_rpCord.in.GetVoltage);
    m_encapsulee.led.in.Initialize = std::ref(m_rpLed.in.Initialize);
    m_encapsulee.led.in.Uninitialize = std::ref(m_rpLed.in.Uninitialize);
}

void ToasterSystemAdvShell::FinalConstruct(const dzn::meta* parentComponentMeta)
{
    // Check the bindings of all boundary ports
    m_encapsulee.api.check_bindings();
    m_rpHeaterElement.check_bindings();
    m_rpCord.check_bindings();
    m_rpLed.check_bindings();

    // Complete the encapsulated component meta information and check the bindings of all encapsulee ports
    m_encapsulee.dzn_meta.parent = parentComponentMeta;
    m_encapsulee.check_bindings();
}

::Dzn::Sts<::My::Project::IToaster> ToasterSystemAdvShell::ProvidesApi()
{
    return {m_encapsulee.api};
}

::Dzn::Mts<::Some::Vendor::IHeaterElement> ToasterSystemAdvShell::RequiresHeaterElement()
{
    return {m_rpHeaterElement};
}

::Dzn::Mts<::My::Project::Hal::IPowerCord> ToasterSystemAdvShell::RequiresCord()
{
    return {m_rpCord};
}

::Dzn::Mts<::My::ILed> ToasterSystemAdvShell::RequiresLed()
{
    return {m_rpLed};
}

} // namespace My::Project
// Generated by: dznpy/adv_shell v1.2.DEV
'''

HH_ALL_MTS_ALL_STS = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// Creator information:
// <none>
//
// User configuration:
// - Encapsulee FQN: My.Project.ToasterSystem
// - Source file basename: ToasterSystem
// - Target file basename: ToasterSystemAdvShell
// - Dezyne facilities: Create all facilities (dispatcher, runtime and locator)
// - Ports (none multiclient):
//     > provides ports: All MTS
//     > requires ports: All STS
//
// Final configuration:
// - Provides ports (Multi-threaded):
//     > api: IToaster
//
// - Requires ports (Single-threaded):
//     > heaterElement: IHeaterElement
//     > cord: IPowerCord
//     > led: ILed
//
// This is generated content. DO NOT MODIFY manually.

// System includes
#include <dzn/locator.hh>
#include <dzn/pump.hh>
#include <dzn/runtime.hh>
// Project includes
#include "ToasterSystem.hh"
#include "Other_Project_Dzn_StrictPort.hh"

namespace My::Project {
struct ToasterSystemAdvShell
{
    ToasterSystemAdvShell(const dzn::locator& prototypeLocator, const std::string& encapsuleeInstanceName = "");
    void FinalConstruct(const dzn::meta* parentComponentMeta = nullptr);

    // Facility accessor
    dzn::locator& Locator();

    // Provides port accessor
    ::Other::Project::Dzn::Mts<::My::Project::IToaster> ProvidesApi();

    // Requires port accessors
    ::Other::Project::Dzn::Sts<::Some::Vendor::IHeaterElement> RequiresHeaterElement();
    ::Other::Project::Dzn::Sts<::My::Project::Hal::IPowerCord> RequiresCord();
    ::Other::Project::Dzn::Sts<::My::ILed> RequiresLed();

private:
    // Facilities
    dzn::runtime m_runtime;
    dzn::pump m_dispatcher;
    dzn::locator m_locator;
    static const dzn::locator& FacilitiesCheck(const dzn::locator& locator);

    // The encapsulated component "ToasterSystem"
    ::My::Project::ToasterSystem m_encapsulee;

    // Boundary provides-port (MTS) to reroute inwards events
    ::My::Project::IToaster m_ppApi;

    // Boundary requires-port (MTS) to reroute inwards events
    // <none>
};
} // namespace My::Project
// Generated by: dznpy/adv_shell v1.2.DEV
'''

CC_ALL_MTS_ALL_STS = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// This is generated content. DO NOT MODIFY manually.

// System include
#include <dzn/runtime.hh>
// Project include
#include "ToasterSystemAdvShell.hh"

namespace My::Project {

const dzn::locator& ToasterSystemAdvShell::FacilitiesCheck(const dzn::locator& locator)
{
    // This class creates the required facilities. But in case the user provided locator argument already contains some or
    // all facilities, it indicates an execution deployment error. Important: each threaded subsystem has its own exclusive
    // instances of the dispatcher and dezyne runtime facilities. They can never be shared with other threaded subsystems.

    if (locator.try_get<dzn::pump>() != nullptr) throw std::runtime_error("ToasterSystemAdvShell: Overlapping dispatcher found (dzn::pump)");
    if (locator.try_get<dzn::runtime>() != nullptr) throw std::runtime_error("ToasterSystemAdvShell: Overlapping Dezyne runtime found (dzn::runtime)");

    return locator;
}

ToasterSystemAdvShell::ToasterSystemAdvShell(const dzn::locator& prototypeLocator, const std::string& encapsuleeInstanceName)
    : m_locator(std::move(FacilitiesCheck(prototypeLocator).clone().set(m_runtime).set(m_dispatcher)))
    , m_encapsulee(m_locator)
    , m_ppApi(m_encapsulee.api)
{
    // Complete the component meta info of the encapsulee and its ports that are configured for MTS
    m_encapsulee.dzn_meta.name = encapsuleeInstanceName;
    m_encapsulee.api.meta.require.name = "api";

    // Boundary provides ports (MTS) initialization:
    // ---------------------------------------------

    // Reroute in-events of boundary provides ports (MTS) via the dispatcher to the encapsulee
    m_ppApi.in.Initialize = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Initialize(); });
    };
    m_ppApi.in.Uninitialize = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Uninitialize(); });
    };
    m_ppApi.in.SetTime = [&](size_t toastingTime) {
        return dzn::shell(m_dispatcher, [&, toastingTime] { return m_encapsulee.api.in.SetTime(toastingTime); });
    };
    m_ppApi.in.GetTime = [&](size_t& toastingTime) {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.GetTime(toastingTime); });
    };
    m_ppApi.in.Toast = [&](std::string motd, std::shared_ptr<ResultInfo>& info) {
        return dzn::shell(m_dispatcher, [&, motd] { return m_encapsulee.api.in.Toast(motd, info); });
    };
    m_ppApi.in.Cancel = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Cancel(); });
    };
    m_ppApi.in.Recover = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Recover(); });
    };

    // Reference out-events of boundary provides ports (MTS) to the respective ports of the encapsulee
    m_encapsulee.api.out.Ok = std::ref(m_ppApi.out.Ok);
    m_encapsulee.api.out.Fail = std::ref(m_ppApi.out.Fail);
    m_encapsulee.api.out.Error = std::ref(m_ppApi.out.Error);

    // Boundary requires ports (MTS) initialization:
    // ---------------------------------------------

    // <None>
}

void ToasterSystemAdvShell::FinalConstruct(const dzn::meta* parentComponentMeta)
{
    // Check the bindings of all boundary ports
    m_ppApi.check_bindings();
    m_encapsulee.heaterElement.check_bindings();
    m_encapsulee.cord.check_bindings();
    m_encapsulee.led.check_bindings();

    // Complete the encapsulated component meta information and check the bindings of all encapsulee ports
    m_encapsulee.dzn_meta.parent = parentComponentMeta;
    m_encapsulee.check_bindings();
}

dzn::locator& ToasterSystemAdvShell::Locator()
{
    return m_locator;
}

::Other::Project::Dzn::Mts<::My::Project::IToaster> ToasterSystemAdvShell::ProvidesApi()
{
    return {m_ppApi};
}

::Other::Project::Dzn::Sts<::Some::Vendor::IHeaterElement> ToasterSystemAdvShell::RequiresHeaterElement()
{
    return {m_encapsulee.heaterElement};
}

::Other::Project::Dzn::Sts<::My::Project::Hal::IPowerCord> ToasterSystemAdvShell::RequiresCord()
{
    return {m_encapsulee.cord};
}

::Other::Project::Dzn::Sts<::My::ILed> ToasterSystemAdvShell::RequiresLed()
{
    return {m_encapsulee.led};
}

} // namespace My::Project
// Generated by: dznpy/adv_shell v1.2.DEV
'''

HH_ALL_MTS_MIXED_TS = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// Creator information:
// <none>
//
// User configuration:
// - Encapsulee FQN: My.Project.ToasterSystem
// - Source file basename: ToasterSystem
// - Target file basename: ToasterSystemAdvShell
// - Dezyne facilities: Create all facilities (dispatcher, runtime and locator)
// - Ports (none multiclient):
//     > provides ports: All MTS
//     > requires ports: STS=['led'] MTS=[<Remaining ports>]
//
// Final configuration:
// - Provides ports (Multi-threaded):
//     > api: IToaster
//
// - Requires ports (Single-threaded):
//     > led: ILed
//
// - Requires ports (Multi-threaded):
//     > heaterElement: IHeaterElement
//     > cord: IPowerCord
//
// This is generated content. DO NOT MODIFY manually.

// System includes
#include <dzn/locator.hh>
#include <dzn/pump.hh>
#include <dzn/runtime.hh>
// Project includes
#include "ToasterSystem.hh"
#include "Dzn_StrictPort.hh"

namespace My::Project {
struct ToasterSystemAdvShell
{
    ToasterSystemAdvShell(const dzn::locator& prototypeLocator, const std::string& encapsuleeInstanceName = "");
    void FinalConstruct(const dzn::meta* parentComponentMeta = nullptr);

    // Facility accessor
    dzn::locator& Locator();

    // Provides port accessor
    ::Dzn::Mts<::My::Project::IToaster> ProvidesApi();

    // Requires port accessors
    ::Dzn::Mts<::Some::Vendor::IHeaterElement> RequiresHeaterElement();
    ::Dzn::Mts<::My::Project::Hal::IPowerCord> RequiresCord();
    ::Dzn::Sts<::My::ILed> RequiresLed();

private:
    // Facilities
    dzn::runtime m_runtime;
    dzn::pump m_dispatcher;
    dzn::locator m_locator;
    static const dzn::locator& FacilitiesCheck(const dzn::locator& locator);

    // The encapsulated component "ToasterSystem"
    ::My::Project::ToasterSystem m_encapsulee;

    // Boundary provides-port (MTS) to reroute inwards events
    ::My::Project::IToaster m_ppApi;

    // Boundary requires-ports (MTS) to reroute inwards events
    ::Some::Vendor::IHeaterElement m_rpHeaterElement;
    ::My::Project::Hal::IPowerCord m_rpCord;
};
} // namespace My::Project
// Generated by: dznpy/adv_shell v1.2.DEV
'''

CC_ALL_MTS_MIXED_TS = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// This is generated content. DO NOT MODIFY manually.

// System include
#include <dzn/runtime.hh>
// Project include
#include "ToasterSystemAdvShell.hh"

namespace My::Project {

const dzn::locator& ToasterSystemAdvShell::FacilitiesCheck(const dzn::locator& locator)
{
    // This class creates the required facilities. But in case the user provided locator argument already contains some or
    // all facilities, it indicates an execution deployment error. Important: each threaded subsystem has its own exclusive
    // instances of the dispatcher and dezyne runtime facilities. They can never be shared with other threaded subsystems.

    if (locator.try_get<dzn::pump>() != nullptr) throw std::runtime_error("ToasterSystemAdvShell: Overlapping dispatcher found (dzn::pump)");
    if (locator.try_get<dzn::runtime>() != nullptr) throw std::runtime_error("ToasterSystemAdvShell: Overlapping Dezyne runtime found (dzn::runtime)");

    return locator;
}

ToasterSystemAdvShell::ToasterSystemAdvShell(const dzn::locator& prototypeLocator, const std::string& encapsuleeInstanceName)
    : m_locator(std::move(FacilitiesCheck(prototypeLocator).clone().set(m_runtime).set(m_dispatcher)))
    , m_encapsulee(m_locator)
    , m_ppApi(m_encapsulee.api)
    , m_rpHeaterElement(m_encapsulee.heaterElement)
    , m_rpCord(m_encapsulee.cord)
{
    // Complete the component meta info of the encapsulee and its ports that are configured for MTS
    m_encapsulee.dzn_meta.name = encapsuleeInstanceName;
    m_encapsulee.api.meta.require.name = "api";
    m_encapsulee.heaterElement.meta.provide.name = "heaterElement";
    m_encapsulee.cord.meta.provide.name = "cord";

    // Boundary provides ports (MTS) initialization:
    // ---------------------------------------------

    // Reroute in-events of boundary provides ports (MTS) via the dispatcher to the encapsulee
    m_ppApi.in.Initialize = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Initialize(); });
    };
    m_ppApi.in.Uninitialize = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Uninitialize(); });
    };
    m_ppApi.in.SetTime = [&](size_t toastingTime) {
        return dzn::shell(m_dispatcher, [&, toastingTime] { return m_encapsulee.api.in.SetTime(toastingTime); });
    };
    m_ppApi.in.GetTime = [&](size_t& toastingTime) {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.GetTime(toastingTime); });
    };
    m_ppApi.in.Toast = [&](std::string motd, std::shared_ptr<ResultInfo>& info) {
        return dzn::shell(m_dispatcher, [&, motd] { return m_encapsulee.api.in.Toast(motd, info); });
    };
    m_ppApi.in.Cancel = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Cancel(); });
    };
    m_ppApi.in.Recover = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Recover(); });
    };

    // Reference out-events of boundary provides ports (MTS) to the respective ports of the encapsulee
    m_encapsulee.api.out.Ok = std::ref(m_ppApi.out.Ok);
    m_encapsulee.api.out.Fail = std::ref(m_ppApi.out.Fail);
    m_encapsulee.api.out.Error = std::ref(m_ppApi.out.Error);

    // Boundary requires ports (MTS) initialization:
    // ---------------------------------------------

    // Reroute out-events of boundary requires ports (MTS) via the dispatcher
    m_rpCord.out.Connected = [&] {
        return m_dispatcher([&] { return m_encapsulee.cord.out.Connected(); });
    };
    m_rpCord.out.Disconnected = [&](My::Project::Hal::Sub::MyLongNamedType exampleParameter) {
        return m_dispatcher([&, exampleParameter] { return m_encapsulee.cord.out.Disconnected(exampleParameter); });
    };

    // Reference in-events of boundary requires ports (MTS) to the respective ports of the encapsulee
    m_encapsulee.heaterElement.in.Initialize = std::ref(m_rpHeaterElement.in.Initialize);
    m_encapsulee.heaterElement.in.Uninitialize = std::ref(m_rpHeaterElement.in.Uninitialize);
    m_encapsulee.heaterElement.in.On = std::ref(m_rpHeaterElement.in.On);
    m_encapsulee.heaterElement.in.Off = std::ref(m_rpHeaterElement.in.Off);
    m_encapsulee.cord.in.Initialize = std::ref(m_rpCord.in.Initialize);
    m_encapsulee.cord.in.Uninitialize = std::ref(m_rpCord.in.Uninitialize);
    m_encapsulee.cord.in.IsConnectedToOutlet = std::ref(m_rpCord.in.IsConnectedToOutlet);
    m_encapsulee.cord.in.GetVoltage = std::ref(m_rpCord.in.GetVoltage);
}

void ToasterSystemAdvShell::FinalConstruct(const dzn::meta* parentComponentMeta)
{
    // Check the bindings of all boundary ports
    m_ppApi.check_bindings();
    m_rpHeaterElement.check_bindings();
    m_rpCord.check_bindings();
    m_encapsulee.led.check_bindings();

    // Complete the encapsulated component meta information and check the bindings of all encapsulee ports
    m_encapsulee.dzn_meta.parent = parentComponentMeta;
    m_encapsulee.check_bindings();
}

dzn::locator& ToasterSystemAdvShell::Locator()
{
    return m_locator;
}

::Dzn::Mts<::My::Project::IToaster> ToasterSystemAdvShell::ProvidesApi()
{
    return {m_ppApi};
}

::Dzn::Mts<::Some::Vendor::IHeaterElement> ToasterSystemAdvShell::RequiresHeaterElement()
{
    return {m_rpHeaterElement};
}

::Dzn::Mts<::My::Project::Hal::IPowerCord> ToasterSystemAdvShell::RequiresCord()
{
    return {m_rpCord};
}

::Dzn::Sts<::My::ILed> ToasterSystemAdvShell::RequiresLed()
{
    return {m_encapsulee.led};
}

} // namespace My::Project
// Generated by: dznpy/adv_shell v1.2.DEV
'''

HH_ALL_STS_MIXED_TS = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// Creator information:
//     ABC
//     DEF
//     GHI
//
// User configuration:
// - Encapsulee FQN: StoneAgeToaster
// - Source file basename: StoneAgeToaster
// - Target file basename: StoneAgeToasterImplComp
// - Dezyne facilities: Create all facilities (dispatcher, runtime and locator)
// - Ports (none multiclient):
//     > provides ports: All STS
//     > requires ports: MTS=['heater'] STS=[<Remaining ports>]
//
// Final configuration:
// - Provides ports (Single-threaded):
//     > api: IToaster
//
// - Requires ports (Single-threaded):
//     > timer: ITimer
//
// - Requires ports (Multi-threaded):
//     > heater: IHeaterElement
//
// This is generated content. DO NOT MODIFY manually.

// System includes
#include <dzn/locator.hh>
#include <dzn/pump.hh>
#include <dzn/runtime.hh>
// Project includes
#include "StoneAgeToaster.hh"
#include "Dzn_StrictPort.hh"

namespace {
struct StoneAgeToasterImplComp
{
    StoneAgeToasterImplComp(const dzn::locator& prototypeLocator, const std::string& encapsuleeInstanceName = "");
    void FinalConstruct(const dzn::meta* parentComponentMeta = nullptr);

    // Facility accessor
    dzn::locator& Locator();

    // Provides port accessor
    ::Dzn::Sts<::My::Project::IToaster> ProvidesApi();

    // Requires port accessors
    ::Dzn::Mts<::Some::Vendor::IHeaterElement> RequiresHeater();
    ::Dzn::Sts<::ITimer> RequiresTimer();

private:
    // Facilities
    dzn::runtime m_runtime;
    dzn::pump m_dispatcher;
    dzn::locator m_locator;
    static const dzn::locator& FacilitiesCheck(const dzn::locator& locator);

    // The encapsulated component "StoneAgeToaster"
    ::StoneAgeToaster m_encapsulee;

    // Boundary provides-port (MTS) to reroute inwards events
    // <none>

    // Boundary requires-port (MTS) to reroute inwards events
    ::Some::Vendor::IHeaterElement m_rpHeater;
};
} // namespace
// Generated by: dznpy/adv_shell v1.2.DEV
'''

CC_ALL_STS_MIXED_TS = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// This is generated content. DO NOT MODIFY manually.

// System include
#include <dzn/runtime.hh>
// Project include
#include "StoneAgeToasterImplComp.hh"

namespace {

const dzn::locator& StoneAgeToasterImplComp::FacilitiesCheck(const dzn::locator& locator)
{
    // This class creates the required facilities. But in case the user provided locator argument already contains some or
    // all facilities, it indicates an execution deployment error. Important: each threaded subsystem has its own exclusive
    // instances of the dispatcher and dezyne runtime facilities. They can never be shared with other threaded subsystems.

    if (locator.try_get<dzn::pump>() != nullptr) throw std::runtime_error("StoneAgeToasterImplComp: Overlapping dispatcher found (dzn::pump)");
    if (locator.try_get<dzn::runtime>() != nullptr) throw std::runtime_error("StoneAgeToasterImplComp: Overlapping Dezyne runtime found (dzn::runtime)");

    return locator;
}

StoneAgeToasterImplComp::StoneAgeToasterImplComp(const dzn::locator& prototypeLocator, const std::string& encapsuleeInstanceName)
    : m_locator(std::move(FacilitiesCheck(prototypeLocator).clone().set(m_runtime).set(m_dispatcher)))
    , m_encapsulee(m_locator)
    , m_rpHeater(m_encapsulee.heater)
{
    // Complete the component meta info of the encapsulee and its ports that are configured for MTS
    m_encapsulee.dzn_meta.name = encapsuleeInstanceName;
    m_encapsulee.heater.meta.provide.name = "heater";

    // Boundary provides ports (MTS) initialization:
    // ---------------------------------------------

    // <None>

    // Boundary requires ports (MTS) initialization:
    // ---------------------------------------------

    // Reference in-events of boundary requires ports (MTS) to the respective ports of the encapsulee
    m_encapsulee.heater.in.Initialize = std::ref(m_rpHeater.in.Initialize);
    m_encapsulee.heater.in.Uninitialize = std::ref(m_rpHeater.in.Uninitialize);
    m_encapsulee.heater.in.On = std::ref(m_rpHeater.in.On);
    m_encapsulee.heater.in.Off = std::ref(m_rpHeater.in.Off);
}

void StoneAgeToasterImplComp::FinalConstruct(const dzn::meta* parentComponentMeta)
{
    // Check the bindings of all boundary ports
    m_encapsulee.api.check_bindings();
    m_rpHeater.check_bindings();
    m_encapsulee.timer.check_bindings();

    // Complete the encapsulated component meta information and check the bindings of all encapsulee ports
    m_encapsulee.dzn_meta.parent = parentComponentMeta;
    m_encapsulee.check_bindings();
}

dzn::locator& StoneAgeToasterImplComp::Locator()
{
    return m_locator;
}

::Dzn::Sts<::My::Project::IToaster> StoneAgeToasterImplComp::ProvidesApi()
{
    return {m_encapsulee.api};
}

::Dzn::Mts<::Some::Vendor::IHeaterElement> StoneAgeToasterImplComp::RequiresHeater()
{
    return {m_rpHeater};
}

::Dzn::Sts<::ITimer> StoneAgeToasterImplComp::RequiresTimer()
{
    return {m_encapsulee.timer};
}

} // namespace
// Generated by: dznpy/adv_shell v1.2.DEV
'''

HH_ALL_MTS = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// Creator information:
// <none>
//
// User configuration:
// - Encapsulee FQN: My.Project.ToasterSystem
// - Source file basename: ToasterSystem
// - Target file basename: ToasterSystemAdvShell
// - Dezyne facilities: Create all facilities (dispatcher, runtime and locator)
// - Ports (none multiclient):
//     > provides/requires: All MTS
//
// Final configuration:
// - Provides ports (Multi-threaded):
//     > api: IToaster
//
// - Requires ports (Multi-threaded):
//     > heaterElement: IHeaterElement
//     > cord: IPowerCord
//     > led: ILed
//
// This is generated content. DO NOT MODIFY manually.

// System includes
#include <dzn/locator.hh>
#include <dzn/pump.hh>
#include <dzn/runtime.hh>
// Project includes
#include "ToasterSystem.hh"
#include "Dzn_StrictPort.hh"

namespace My::Project {
struct ToasterSystemAdvShell
{
    ToasterSystemAdvShell(const dzn::locator& prototypeLocator, const std::string& encapsuleeInstanceName = "");
    void FinalConstruct(const dzn::meta* parentComponentMeta = nullptr);

    // Facility accessor
    dzn::locator& Locator();

    // Provides port accessor
    ::Dzn::Mts<::My::Project::IToaster> ProvidesApi();

    // Requires port accessors
    ::Dzn::Mts<::Some::Vendor::IHeaterElement> RequiresHeaterElement();
    ::Dzn::Mts<::My::Project::Hal::IPowerCord> RequiresCord();
    ::Dzn::Mts<::My::ILed> RequiresLed();

private:
    // Facilities
    dzn::runtime m_runtime;
    dzn::pump m_dispatcher;
    dzn::locator m_locator;
    static const dzn::locator& FacilitiesCheck(const dzn::locator& locator);

    // The encapsulated component "ToasterSystem"
    ::My::Project::ToasterSystem m_encapsulee;

    // Boundary provides-port (MTS) to reroute inwards events
    ::My::Project::IToaster m_ppApi;

    // Boundary requires-ports (MTS) to reroute inwards events
    ::Some::Vendor::IHeaterElement m_rpHeaterElement;
    ::My::Project::Hal::IPowerCord m_rpCord;
    ::My::ILed m_rpLed;
};
} // namespace My::Project
// Generated by: dznpy/adv_shell v1.2.DEV
'''

CC_ALL_MTS = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// This is generated content. DO NOT MODIFY manually.

// System include
#include <dzn/runtime.hh>
// Project include
#include "ToasterSystemAdvShell.hh"

namespace My::Project {

const dzn::locator& ToasterSystemAdvShell::FacilitiesCheck(const dzn::locator& locator)
{
    // This class creates the required facilities. But in case the user provided locator argument already contains some or
    // all facilities, it indicates an execution deployment error. Important: each threaded subsystem has its own exclusive
    // instances of the dispatcher and dezyne runtime facilities. They can never be shared with other threaded subsystems.

    if (locator.try_get<dzn::pump>() != nullptr) throw std::runtime_error("ToasterSystemAdvShell: Overlapping dispatcher found (dzn::pump)");
    if (locator.try_get<dzn::runtime>() != nullptr) throw std::runtime_error("ToasterSystemAdvShell: Overlapping Dezyne runtime found (dzn::runtime)");

    return locator;
}

ToasterSystemAdvShell::ToasterSystemAdvShell(const dzn::locator& prototypeLocator, const std::string& encapsuleeInstanceName)
    : m_locator(std::move(FacilitiesCheck(prototypeLocator).clone().set(m_runtime).set(m_dispatcher)))
    , m_encapsulee(m_locator)
    , m_ppApi(m_encapsulee.api)
    , m_rpHeaterElement(m_encapsulee.heaterElement)
    , m_rpCord(m_encapsulee.cord)
    , m_rpLed(m_encapsulee.led)
{
    // Complete the component meta info of the encapsulee and its ports that are configured for MTS
    m_encapsulee.dzn_meta.name = encapsuleeInstanceName;
    m_encapsulee.api.meta.require.name = "api";
    m_encapsulee.heaterElement.meta.provide.name = "heaterElement";
    m_encapsulee.cord.meta.provide.name = "cord";
    m_encapsulee.led.meta.provide.name = "led";

    // Boundary provides ports (MTS) initialization:
    // ---------------------------------------------

    // Reroute in-events of boundary provides ports (MTS) via the dispatcher to the encapsulee
    m_ppApi.in.Initialize = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Initialize(); });
    };
    m_ppApi.in.Uninitialize = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Uninitialize(); });
    };
    m_ppApi.in.SetTime = [&](size_t toastingTime) {
        return dzn::shell(m_dispatcher, [&, toastingTime] { return m_encapsulee.api.in.SetTime(toastingTime); });
    };
    m_ppApi.in.GetTime = [&](size_t& toastingTime) {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.GetTime(toastingTime); });
    };
    m_ppApi.in.Toast = [&](std::string motd, std::shared_ptr<ResultInfo>& info) {
        return dzn::shell(m_dispatcher, [&, motd] { return m_encapsulee.api.in.Toast(motd, info); });
    };
    m_ppApi.in.Cancel = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Cancel(); });
    };
    m_ppApi.in.Recover = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Recover(); });
    };

    // Reference out-events of boundary provides ports (MTS) to the respective ports of the encapsulee
    m_encapsulee.api.out.Ok = std::ref(m_ppApi.out.Ok);
    m_encapsulee.api.out.Fail = std::ref(m_ppApi.out.Fail);
    m_encapsulee.api.out.Error = std::ref(m_ppApi.out.Error);

    // Boundary requires ports (MTS) initialization:
    // ---------------------------------------------

    // Reroute out-events of boundary requires ports (MTS) via the dispatcher
    m_rpCord.out.Connected = [&] {
        return m_dispatcher([&] { return m_encapsulee.cord.out.Connected(); });
    };
    m_rpCord.out.Disconnected = [&](My::Project::Hal::Sub::MyLongNamedType exampleParameter) {
        return m_dispatcher([&, exampleParameter] { return m_encapsulee.cord.out.Disconnected(exampleParameter); });
    };
    m_rpLed.out.GlitchOccurred = [&] {
        return m_dispatcher([&] { return m_encapsulee.led.out.GlitchOccurred(); });
    };

    // Reference in-events of boundary requires ports (MTS) to the respective ports of the encapsulee
    m_encapsulee.heaterElement.in.Initialize = std::ref(m_rpHeaterElement.in.Initialize);
    m_encapsulee.heaterElement.in.Uninitialize = std::ref(m_rpHeaterElement.in.Uninitialize);
    m_encapsulee.heaterElement.in.On = std::ref(m_rpHeaterElement.in.On);
    m_encapsulee.heaterElement.in.Off = std::ref(m_rpHeaterElement.in.Off);
    m_encapsulee.cord.in.Initialize = std::ref(m_rpCord.in.Initialize);
    m_encapsulee.cord.in.Uninitialize = std::ref(m_rpCord.in.Uninitialize);
    m_encapsulee.cord.in.IsConnectedToOutlet = std::ref(m_rpCord.in.IsConnectedToOutlet);
    m_encapsulee.cord.in.GetVoltage = std::ref(m_rpCord.in.GetVoltage);
    m_encapsulee.led.in.Initialize = std::ref(m_rpLed.in.Initialize);
    m_encapsulee.led.in.Uninitialize = std::ref(m_rpLed.in.Uninitialize);
}

void ToasterSystemAdvShell::FinalConstruct(const dzn::meta* parentComponentMeta)
{
    // Check the bindings of all boundary ports
    m_ppApi.check_bindings();
    m_rpHeaterElement.check_bindings();
    m_rpCord.check_bindings();
    m_rpLed.check_bindings();

    // Complete the encapsulated component meta information and check the bindings of all encapsulee ports
    m_encapsulee.dzn_meta.parent = parentComponentMeta;
    m_encapsulee.check_bindings();
}

dzn::locator& ToasterSystemAdvShell::Locator()
{
    return m_locator;
}

::Dzn::Mts<::My::Project::IToaster> ToasterSystemAdvShell::ProvidesApi()
{
    return {m_ppApi};
}

::Dzn::Mts<::Some::Vendor::IHeaterElement> ToasterSystemAdvShell::RequiresHeaterElement()
{
    return {m_rpHeaterElement};
}

::Dzn::Mts<::My::Project::Hal::IPowerCord> ToasterSystemAdvShell::RequiresCord()
{
    return {m_rpCord};
}

::Dzn::Mts<::My::ILed> ToasterSystemAdvShell::RequiresLed()
{
    return {m_rpLed};
}

} // namespace My::Project
// Generated by: dznpy/adv_shell v1.2.DEV
'''

HH_ALL_STS = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// Creator information:
//     ABC
//     DEF
//     GHI
//
// User configuration:
// - Encapsulee FQN: StoneAgeToaster
// - Source file basename: StoneAgeToaster
// - Target file basename: StoneAgeToasterImplComp
// - Dezyne facilities: Import facilities (by reference) from the user provided dzn::locator argument
// - Ports (none multiclient):
//     > provides/requires: All STS
//
// Final configuration:
// - Provides ports (Single-threaded):
//     > api: IToaster
//
// - Requires ports (Single-threaded):
//     > heater: IHeaterElement
//     > timer: ITimer
//
// This is generated content. DO NOT MODIFY manually.

// System includes
#include <dzn/locator.hh>
#include <dzn/pump.hh>
// Project includes
#include "StoneAgeToaster.hh"
#include "Dzn_StrictPort.hh"

namespace {
struct StoneAgeToasterImplComp
{
    StoneAgeToasterImplComp(const dzn::locator& locator, const std::string& encapsuleeInstanceName = "");
    void FinalConstruct(const dzn::meta* parentComponentMeta = nullptr);

    // Facility accessor
    // <none>

    // Provides port accessor
    ::Dzn::Sts<::My::Project::IToaster> ProvidesApi();

    // Requires port accessors
    ::Dzn::Sts<::Some::Vendor::IHeaterElement> RequiresHeater();
    ::Dzn::Sts<::ITimer> RequiresTimer();

private:
    // Facilities
    dzn::pump& m_dispatcher;
    static const dzn::locator& FacilitiesCheck(const dzn::locator& locator);

    // The encapsulated component "StoneAgeToaster"
    ::StoneAgeToaster m_encapsulee;

    // Boundary provides-port (MTS) to reroute inwards events
    // <none>

    // Boundary requires-port (MTS) to reroute inwards events
    // <none>
};
} // namespace
// Generated by: dznpy/adv_shell v1.2.DEV
'''

CC_ALL_STS = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// This is generated content. DO NOT MODIFY manually.

// System include
#include <dzn/runtime.hh>
// Project include
#include "StoneAgeToasterImplComp.hh"

namespace {

const dzn::locator& StoneAgeToasterImplComp::FacilitiesCheck(const dzn::locator& locator)
{
    // This class imports the required facilities that must be provided by the user via the locator argument.

    if (locator.try_get<dzn::pump>() == nullptr) throw std::runtime_error("StoneAgeToasterImplComp: Dispatcher missing (dzn::pump)");
    if (locator.try_get<dzn::runtime>() == nullptr) throw std::runtime_error("StoneAgeToasterImplComp: Dezyne runtime missing (dzn::runtime)");

    return locator;
}

StoneAgeToasterImplComp::StoneAgeToasterImplComp(const dzn::locator& locator, const std::string& encapsuleeInstanceName)
    : m_dispatcher(FacilitiesCheck(locator).get<dzn::pump>())
    , m_encapsulee(locator)
{
    // Complete the component meta info of the encapsulee and its ports that are configured for MTS
    m_encapsulee.dzn_meta.name = encapsuleeInstanceName;

    // Boundary provides ports (MTS) initialization:
    // ---------------------------------------------

    // <None>

    // Boundary requires ports (MTS) initialization:
    // ---------------------------------------------

    // <None>
}

void StoneAgeToasterImplComp::FinalConstruct(const dzn::meta* parentComponentMeta)
{
    // Check the bindings of all boundary ports
    m_encapsulee.api.check_bindings();
    m_encapsulee.heater.check_bindings();
    m_encapsulee.timer.check_bindings();

    // Complete the encapsulated component meta information and check the bindings of all encapsulee ports
    m_encapsulee.dzn_meta.parent = parentComponentMeta;
    m_encapsulee.check_bindings();
}

::Dzn::Sts<::My::Project::IToaster> StoneAgeToasterImplComp::ProvidesApi()
{
    return {m_encapsulee.api};
}

::Dzn::Sts<::Some::Vendor::IHeaterElement> StoneAgeToasterImplComp::RequiresHeater()
{
    return {m_encapsulee.heater};
}

::Dzn::Sts<::ITimer> StoneAgeToasterImplComp::RequiresTimer()
{
    return {m_encapsulee.timer};
}

} // namespace
// Generated by: dznpy/adv_shell v1.2.DEV
'''

HH_ALL_MTS_MULTICLIENT = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// Creator information:
// <none>
//
// User configuration:
// - Encapsulee FQN: My.Project.ExclusiveToaster
// - Source file basename: ExclusiveToaster
// - Target file basename: ExclusiveToasterAdvShell
// - Dezyne facilities: Create all facilities (dispatcher, runtime and locator)
// - Ports:
//     > provides/requires: All MTS
//     > multiclient: Out-event ClientSelector port "api" (Claim event "Claim" with granting reply value "Ok", Release event "Release")
//
// Final configuration:
// - Provides ports (Multi-threaded):
//     > lifecycle: ILifecycle
//     > api: *MultiClient* IExclusiveToaster (with claim_event=Claim, claim_granting_reply=My.Result.Ok, release_event=Release)
//
// - Requires ports (Multi-threaded):
//     > heater: IHeaterElement
//     > cord: IPowerCord
//     > timer: ITimer
//
// This is generated content. DO NOT MODIFY manually.

// System includes
#include <dzn/locator.hh>
#include <dzn/pump.hh>
#include <dzn/runtime.hh>
// Project includes
#include "ExclusiveToaster.hh"
#include "Dzn_StrictPort.hh"
#include "Dzn_ILog.hh"
#include "Dzn_MultiClientSelector.hh"

namespace My::Project {
struct ExclusiveToasterAdvShell
{
    ExclusiveToasterAdvShell(const dzn::locator& prototypeLocator, const ::Dzn::ILog& multiclientLog, const std::string& encapsuleeInstanceName = "");
    void FinalConstruct(const dzn::meta* parentComponentMeta = nullptr);

    // Facility accessor
    dzn::locator& Locator();

    // Provides port accessors
    ::Dzn::Mts<::My::ILifecycle> ProvidesLifecycle();
    ::Dzn::Mts<::My::IExclusiveToaster> ProvidesMultiClientApi(const ::Dzn::ClientIdentifier& identifier);

    // Provides port helper
    std::vector<::Dzn::ClientIdentifier> GetApiClientIdentifiers() const;

    // Requires port accessors
    ::Dzn::Mts<::Some::Vendor::IHeaterElement> RequiresHeater();
    ::Dzn::Mts<::My::Project::Hal::IPowerCord> RequiresCord();
    ::Dzn::Mts<::ITimer> RequiresTimer();

private:
    // Facilities
    dzn::runtime m_runtime;
    dzn::pump m_dispatcher;
    dzn::locator m_locator;
    static const dzn::locator& FacilitiesCheck(const dzn::locator& locator);

    // The encapsulated component "ExclusiveToaster"
    ::My::Project::ExclusiveToaster m_encapsulee;

    // Boundary provides-port (MTS) to reroute inwards events
    ::My::ILifecycle m_ppLifecycle;

    // Boundary provides-port (MTS) to reroute inwards events and redirect outwards events to multi clients
    ::Dzn::MultiClientSelector<::My::IExclusiveToaster> m_ppApi;

    // Provides port helper
    ::My::IExclusiveToaster InitializePortApi(const ::Dzn::ClientIdentifier& identifier);

    // Boundary requires-ports (MTS) to reroute inwards events
    ::Some::Vendor::IHeaterElement m_rpHeater;
    ::My::Project::Hal::IPowerCord m_rpCord;
    ::ITimer m_rpTimer;
};
} // namespace My::Project
// Generated by: dznpy/adv_shell v1.2.DEV
'''

CC_ALL_MTS_MULTICLIENT = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// This is generated content. DO NOT MODIFY manually.

// System include
#include <dzn/runtime.hh>
// Project include
#include "ExclusiveToasterAdvShell.hh"

namespace My::Project {

const dzn::locator& ExclusiveToasterAdvShell::FacilitiesCheck(const dzn::locator& locator)
{
    // This class creates the required facilities. But in case the user provided locator argument already contains some or
    // all facilities, it indicates an execution deployment error. Important: each threaded subsystem has its own exclusive
    // instances of the dispatcher and dezyne runtime facilities. They can never be shared with other threaded subsystems.

    if (locator.try_get<dzn::pump>() != nullptr) throw std::runtime_error("ExclusiveToasterAdvShell: Overlapping dispatcher found (dzn::pump)");
    if (locator.try_get<dzn::runtime>() != nullptr) throw std::runtime_error("ExclusiveToasterAdvShell: Overlapping Dezyne runtime found (dzn::runtime)");

    return locator;
}

ExclusiveToasterAdvShell::ExclusiveToasterAdvShell(const dzn::locator& prototypeLocator, const ::Dzn::ILog& multiclientLog, const std::string& encapsuleeInstanceName)
    : m_locator(std::move(FacilitiesCheck(prototypeLocator).clone().set(m_runtime).set(m_dispatcher)))
    , m_encapsulee(m_locator)
    , m_ppLifecycle(m_encapsulee.lifecycle)
    , m_ppApi(multiclientLog, "api", [this](const auto& identifier) { return InitializePortApi(identifier); })
    , m_rpHeater(m_encapsulee.heater)
    , m_rpCord(m_encapsulee.cord)
    , m_rpTimer(m_encapsulee.timer)
{
    // Complete the component meta info of the encapsulee and its ports that are configured for MTS
    m_encapsulee.dzn_meta.name = encapsuleeInstanceName;
    m_encapsulee.lifecycle.meta.require.name = "lifecycle";
    m_encapsulee.api.meta.require.name = "api";
    m_encapsulee.heater.meta.provide.name = "heater";
    m_encapsulee.cord.meta.provide.name = "cord";
    m_encapsulee.timer.meta.provide.name = "timer";

    // Boundary provides ports (MTS) initialization:
    // ---------------------------------------------

    // Reroute in-events of boundary provides ports (MTS) via the dispatcher to the encapsulee
    m_ppLifecycle.in.Initialize = [&](std::shared_ptr<ResultInfo>& info) {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.lifecycle.in.Initialize(info); });
    };
    m_ppLifecycle.in.Uninitialize = [&](std::shared_ptr<ResultInfo>& info) {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.lifecycle.in.Uninitialize(info); });
    };

    // Reroute in-events of the internal arbitered multiclient port via the dispatcher to the encapsulee
    m_ppApi().in.Claim = [&](std::shared_ptr<ResultInfo>& info) {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Claim(info); });
    };
    m_ppApi().in.Release = [&](std::string& goodbye) {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Release(goodbye); });
    };
    m_ppApi().in.Toast = [&](std::string motd, std::shared_ptr<ResultInfo>& info) {
        return dzn::shell(m_dispatcher, [&, motd] { return m_encapsulee.api.in.Toast(motd, info); });
    };
    m_ppApi().in.Cancel = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Cancel(); });
    };

    // Reroute out-events of the internal arbitered multiclient port via the MultiClientSelector facility to the current Client having the claim
    m_ppApi().out.Ok = [&] {
        auto lockAndData = m_ppApi.CurrentClient();
        if (lockAndData->has_value()) lockAndData->value().get().dznPort.out.Ok();
    };
    m_ppApi().out.Fail = [&](std::shared_ptr<ResultInfo> info) {
        auto lockAndData = m_ppApi.CurrentClient();
        if (lockAndData->has_value()) lockAndData->value().get().dznPort.out.Fail(info);
    };

    // Reference out-events of the encapsulee to the internal arbitered multiclient port
    m_encapsulee.api.out.Ok = std::ref(m_ppApi().out.Ok);
    m_encapsulee.api.out.Fail = std::ref(m_ppApi().out.Fail);

    // Boundary requires ports (MTS) initialization:
    // ---------------------------------------------

    // Reroute out-events of boundary requires ports (MTS) via the dispatcher
    m_rpCord.out.Connected = [&] {
        return m_dispatcher([&] { return m_encapsulee.cord.out.Connected(); });
    };
    m_rpCord.out.Disconnected = [&](My::Project::Hal::Sub::MyLongNamedType exampleParameter) {
        return m_dispatcher([&, exampleParameter] { return m_encapsulee.cord.out.Disconnected(exampleParameter); });
    };
    m_rpTimer.out.Timeout = [&] {
        return m_dispatcher([&] { return m_encapsulee.timer.out.Timeout(); });
    };

    // Reference in-events of boundary requires ports (MTS) to the respective ports of the encapsulee
    m_encapsulee.heater.in.Initialize = std::ref(m_rpHeater.in.Initialize);
    m_encapsulee.heater.in.Uninitialize = std::ref(m_rpHeater.in.Uninitialize);
    m_encapsulee.heater.in.On = std::ref(m_rpHeater.in.On);
    m_encapsulee.heater.in.Off = std::ref(m_rpHeater.in.Off);
    m_encapsulee.cord.in.Initialize = std::ref(m_rpCord.in.Initialize);
    m_encapsulee.cord.in.Uninitialize = std::ref(m_rpCord.in.Uninitialize);
    m_encapsulee.cord.in.IsConnectedToOutlet = std::ref(m_rpCord.in.IsConnectedToOutlet);
    m_encapsulee.cord.in.GetVoltage = std::ref(m_rpCord.in.GetVoltage);
    m_encapsulee.timer.in.Create = std::ref(m_rpTimer.in.Create);
    m_encapsulee.timer.in.Cancel = std::ref(m_rpTimer.in.Cancel);
}

void ExclusiveToasterAdvShell::FinalConstruct(const dzn::meta* parentComponentMeta)
{
    // Call final construct on multiclient port
    m_ppApi.FinalConstruct();

    // Check the bindings of all boundary ports
    m_ppLifecycle.check_bindings();
    m_rpHeater.check_bindings();
    m_rpCord.check_bindings();
    m_rpTimer.check_bindings();

    // Complete the encapsulated component meta information and check the bindings of all encapsulee ports
    m_encapsulee.dzn_meta.parent = parentComponentMeta;
    m_encapsulee.check_bindings();
}

dzn::locator& ExclusiveToasterAdvShell::Locator()
{
    return m_locator;
}

::Dzn::Mts<::My::ILifecycle> ExclusiveToasterAdvShell::ProvidesLifecycle()
{
    return {m_ppLifecycle};
}

::Dzn::Mts<::My::IExclusiveToaster> ExclusiveToasterAdvShell::ProvidesMultiClientApi(const ::Dzn::ClientIdentifier& identifier)
{
    return {m_ppApi.Index(identifier).dznPort};
}

std::vector<::Dzn::ClientIdentifier> ExclusiveToasterAdvShell::GetApiClientIdentifiers() const
{
    return m_ppApi.GetClientIdentifiers();
}

::Dzn::Mts<::Some::Vendor::IHeaterElement> ExclusiveToasterAdvShell::RequiresHeater()
{
    return {m_rpHeater};
}

::Dzn::Mts<::My::Project::Hal::IPowerCord> ExclusiveToasterAdvShell::RequiresCord()
{
    return {m_rpCord};
}

::Dzn::Mts<::ITimer> ExclusiveToasterAdvShell::RequiresTimer()
{
    return {m_rpTimer};
}

::My::IExclusiveToaster ExclusiveToasterAdvShell::InitializePortApi(const ::Dzn::ClientIdentifier& identifier)
{
    auto port(::Dzn::CreatePort<::My::IExclusiveToaster>("api", "arbiterApi"));

    port.in.Claim = [&, identifier](std::shared_ptr<ResultInfo>& info) {
        const auto r = m_ppApi.Arbitered().in.Claim(info);
        if (r == ::My::Result::Ok) m_ppApi.Select(identifier);
        return r;
    };
    port.in.Release = [&, identifier](std::string& goodbye) {
        m_ppApi.Arbitered().in.Release(goodbye);
        m_ppApi.Deselect(identifier);
    };
    port.in.Toast = std::ref(m_ppApi().in.Toast);
    port.in.Cancel = std::ref(m_ppApi().in.Cancel);

    return port;
}

} // namespace My::Project
// Generated by: dznpy/adv_shell v1.2.DEV
'''

HH_ALL_MTS_DUMMY_MULTICLIENT = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// Creator information:
// <none>
//
// User configuration:
// - Encapsulee FQN: My.DummyExclusiveToaster
// - Source file basename: DummyExclusiveToaster
// - Target file basename: DummyExclusiveToasterAdvShell
// - Dezyne facilities: Create all facilities (dispatcher, runtime and locator)
// - Ports:
//     > provides/requires: All MTS
//     > multiclient: Out-event ClientSelector port "api" (Claim event "Claim" with granting reply value "Ok", Release event "Release")
//
// Final configuration:
// - Provides ports (Multi-threaded):
//     > lifecycle: ILifecycle
//     > api: *MultiClient* IExclusiveToaster (with claim_event=Claim, claim_granting_reply=My.Result.Ok, release_event=Release)
//
// This is generated content. DO NOT MODIFY manually.

// System includes
#include <dzn/locator.hh>
#include <dzn/pump.hh>
#include <dzn/runtime.hh>
// Project includes
#include "DummyExclusiveToaster.hh"
#include "Dzn_StrictPort.hh"
#include "Dzn_ILog.hh"
#include "Dzn_MultiClientSelector.hh"

namespace My {
struct DummyExclusiveToasterAdvShell
{
    DummyExclusiveToasterAdvShell(const dzn::locator& prototypeLocator, const ::Dzn::ILog& multiclientLog, const std::string& encapsuleeInstanceName = "");
    void FinalConstruct(const dzn::meta* parentComponentMeta = nullptr);

    // Facility accessor
    dzn::locator& Locator();

    // Provides port accessors
    ::Dzn::Mts<::My::ILifecycle> ProvidesLifecycle();
    ::Dzn::Mts<::My::IExclusiveToaster> ProvidesMultiClientApi(const ::Dzn::ClientIdentifier& identifier);

    // Provides port helper
    std::vector<::Dzn::ClientIdentifier> GetApiClientIdentifiers() const;

private:
    // Facilities
    dzn::runtime m_runtime;
    dzn::pump m_dispatcher;
    dzn::locator m_locator;
    static const dzn::locator& FacilitiesCheck(const dzn::locator& locator);

    // The encapsulated component "DummyExclusiveToaster"
    ::My::DummyExclusiveToaster m_encapsulee;

    // Boundary provides-port (MTS) to reroute inwards events
    ::My::ILifecycle m_ppLifecycle;

    // Boundary provides-port (MTS) to reroute inwards events and redirect outwards events to multi clients
    ::Dzn::MultiClientSelector<::My::IExclusiveToaster> m_ppApi;

    // Provides port helper
    ::My::IExclusiveToaster InitializePortApi(const ::Dzn::ClientIdentifier& identifier);
};
} // namespace My
// Generated by: dznpy/adv_shell v1.2.DEV
'''

CC_ALL_MTS_DUMMY_MULTICLIENT = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// This is generated content. DO NOT MODIFY manually.

// System include
#include <dzn/runtime.hh>
// Project include
#include "DummyExclusiveToasterAdvShell.hh"

namespace My {

const dzn::locator& DummyExclusiveToasterAdvShell::FacilitiesCheck(const dzn::locator& locator)
{
    // This class creates the required facilities. But in case the user provided locator argument already contains some or
    // all facilities, it indicates an execution deployment error. Important: each threaded subsystem has its own exclusive
    // instances of the dispatcher and dezyne runtime facilities. They can never be shared with other threaded subsystems.

    if (locator.try_get<dzn::pump>() != nullptr) throw std::runtime_error("DummyExclusiveToasterAdvShell: Overlapping dispatcher found (dzn::pump)");
    if (locator.try_get<dzn::runtime>() != nullptr) throw std::runtime_error("DummyExclusiveToasterAdvShell: Overlapping Dezyne runtime found (dzn::runtime)");

    return locator;
}

DummyExclusiveToasterAdvShell::DummyExclusiveToasterAdvShell(const dzn::locator& prototypeLocator, const ::Dzn::ILog& multiclientLog, const std::string& encapsuleeInstanceName)
    : m_locator(std::move(FacilitiesCheck(prototypeLocator).clone().set(m_runtime).set(m_dispatcher)))
    , m_encapsulee(m_locator)
    , m_ppLifecycle(m_encapsulee.lifecycle)
    , m_ppApi(multiclientLog, "api", [this](const auto& identifier) { return InitializePortApi(identifier); })
{
    // Complete the component meta info of the encapsulee and its ports that are configured for MTS
    m_encapsulee.dzn_meta.name = encapsuleeInstanceName;
    m_encapsulee.lifecycle.meta.require.name = "lifecycle";
    m_encapsulee.api.meta.require.name = "api";

    // Boundary provides ports (MTS) initialization:
    // ---------------------------------------------

    // Reroute in-events of boundary provides ports (MTS) via the dispatcher to the encapsulee
    m_ppLifecycle.in.Initialize = [&](std::shared_ptr<ResultInfo>& info) {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.lifecycle.in.Initialize(info); });
    };
    m_ppLifecycle.in.Uninitialize = [&](std::shared_ptr<ResultInfo>& info) {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.lifecycle.in.Uninitialize(info); });
    };

    // Reroute in-events of the internal arbitered multiclient port via the dispatcher to the encapsulee
    m_ppApi().in.Claim = [&](std::shared_ptr<ResultInfo>& info) {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Claim(info); });
    };
    m_ppApi().in.Release = [&](std::string& goodbye) {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Release(goodbye); });
    };
    m_ppApi().in.Toast = [&](std::string motd, std::shared_ptr<ResultInfo>& info) {
        return dzn::shell(m_dispatcher, [&, motd] { return m_encapsulee.api.in.Toast(motd, info); });
    };
    m_ppApi().in.Cancel = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Cancel(); });
    };

    // Reroute out-events of the internal arbitered multiclient port via the MultiClientSelector facility to the current Client having the claim
    m_ppApi().out.Ok = [&] {
        auto lockAndData = m_ppApi.CurrentClient();
        if (lockAndData->has_value()) lockAndData->value().get().dznPort.out.Ok();
    };
    m_ppApi().out.Fail = [&](std::shared_ptr<ResultInfo> info) {
        auto lockAndData = m_ppApi.CurrentClient();
        if (lockAndData->has_value()) lockAndData->value().get().dznPort.out.Fail(info);
    };

    // Reference out-events of the encapsulee to the internal arbitered multiclient port
    m_encapsulee.api.out.Ok = std::ref(m_ppApi().out.Ok);
    m_encapsulee.api.out.Fail = std::ref(m_ppApi().out.Fail);

    // Boundary requires ports (MTS) initialization:
    // ---------------------------------------------

    // <None>
}

void DummyExclusiveToasterAdvShell::FinalConstruct(const dzn::meta* parentComponentMeta)
{
    // Call final construct on multiclient port
    m_ppApi.FinalConstruct();

    // Check the bindings of all boundary ports
    m_ppLifecycle.check_bindings();

    // Complete the encapsulated component meta information and check the bindings of all encapsulee ports
    m_encapsulee.dzn_meta.parent = parentComponentMeta;
    m_encapsulee.check_bindings();
}

dzn::locator& DummyExclusiveToasterAdvShell::Locator()
{
    return m_locator;
}

::Dzn::Mts<::My::ILifecycle> DummyExclusiveToasterAdvShell::ProvidesLifecycle()
{
    return {m_ppLifecycle};
}

::Dzn::Mts<::My::IExclusiveToaster> DummyExclusiveToasterAdvShell::ProvidesMultiClientApi(const ::Dzn::ClientIdentifier& identifier)
{
    return {m_ppApi.Index(identifier).dznPort};
}

std::vector<::Dzn::ClientIdentifier> DummyExclusiveToasterAdvShell::GetApiClientIdentifiers() const
{
    return m_ppApi.GetClientIdentifiers();
}

::My::IExclusiveToaster DummyExclusiveToasterAdvShell::InitializePortApi(const ::Dzn::ClientIdentifier& identifier)
{
    auto port(::Dzn::CreatePort<::My::IExclusiveToaster>("api", "arbiterApi"));

    port.in.Claim = [&, identifier](std::shared_ptr<ResultInfo>& info) {
        const auto r = m_ppApi.Arbitered().in.Claim(info);
        if (r == ::My::Result::Ok) m_ppApi.Select(identifier);
        return r;
    };
    port.in.Release = [&, identifier](std::string& goodbye) {
        m_ppApi.Arbitered().in.Release(goodbye);
        m_ppApi.Deselect(identifier);
    };
    port.in.Toast = std::ref(m_ppApi().in.Toast);
    port.in.Cancel = std::ref(m_ppApi().in.Cancel);

    return port;
}

} // namespace My
// Generated by: dznpy/adv_shell v1.2.DEV
'''

HH_DUMMY_ALL_MTS = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// Creator information:
//     My Dummy
//
// User configuration:
// - Encapsulee FQN: My.DummyToaster
// - Source file basename: DummyToaster
// - Target file basename: DummyToasterAdvShell
// - Dezyne facilities: Create all facilities (dispatcher, runtime and locator)
// - Ports (none multiclient):
//     > provides/requires: All MTS
//
// Final configuration:
// - Provides ports (Multi-threaded):
//     > api: IToaster
//
// This is generated content. DO NOT MODIFY manually.

// System includes
#include <dzn/locator.hh>
#include <dzn/pump.hh>
#include <dzn/runtime.hh>
// Project includes
#include "DummyToaster.hh"
#include "Dzn_StrictPort.hh"

namespace My {
struct DummyToasterAdvShell
{
    DummyToasterAdvShell(const dzn::locator& prototypeLocator, const std::string& encapsuleeInstanceName = "");
    void FinalConstruct(const dzn::meta* parentComponentMeta = nullptr);

    // Facility accessor
    dzn::locator& Locator();

    // Provides port accessor
    ::Dzn::Mts<::My::Project::IToaster> ProvidesApi();

private:
    // Facilities
    dzn::runtime m_runtime;
    dzn::pump m_dispatcher;
    dzn::locator m_locator;
    static const dzn::locator& FacilitiesCheck(const dzn::locator& locator);

    // The encapsulated component "DummyToaster"
    ::My::DummyToaster m_encapsulee;

    // Boundary provides-port (MTS) to reroute inwards events
    ::My::Project::IToaster m_ppApi;
};
} // namespace My
// Generated by: dznpy/adv_shell v1.2.DEV
'''

CC_DUMMY_ALL_MTS = '''\
// Copyright Example Line 1
// Copyright Example Line 2
//
// Advanced Shell
//
// This is generated content. DO NOT MODIFY manually.

// System include
#include <dzn/runtime.hh>
// Project include
#include "DummyToasterAdvShell.hh"

namespace My {

const dzn::locator& DummyToasterAdvShell::FacilitiesCheck(const dzn::locator& locator)
{
    // This class creates the required facilities. But in case the user provided locator argument already contains some or
    // all facilities, it indicates an execution deployment error. Important: each threaded subsystem has its own exclusive
    // instances of the dispatcher and dezyne runtime facilities. They can never be shared with other threaded subsystems.

    if (locator.try_get<dzn::pump>() != nullptr) throw std::runtime_error("DummyToasterAdvShell: Overlapping dispatcher found (dzn::pump)");
    if (locator.try_get<dzn::runtime>() != nullptr) throw std::runtime_error("DummyToasterAdvShell: Overlapping Dezyne runtime found (dzn::runtime)");

    return locator;
}

DummyToasterAdvShell::DummyToasterAdvShell(const dzn::locator& prototypeLocator, const std::string& encapsuleeInstanceName)
    : m_locator(std::move(FacilitiesCheck(prototypeLocator).clone().set(m_runtime).set(m_dispatcher)))
    , m_encapsulee(m_locator)
    , m_ppApi(m_encapsulee.api)
{
    // Complete the component meta info of the encapsulee and its ports that are configured for MTS
    m_encapsulee.dzn_meta.name = encapsuleeInstanceName;
    m_encapsulee.api.meta.require.name = "api";

    // Boundary provides ports (MTS) initialization:
    // ---------------------------------------------

    // Reroute in-events of boundary provides ports (MTS) via the dispatcher to the encapsulee
    m_ppApi.in.Initialize = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Initialize(); });
    };
    m_ppApi.in.Uninitialize = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Uninitialize(); });
    };
    m_ppApi.in.SetTime = [&](size_t toastingTime) {
        return dzn::shell(m_dispatcher, [&, toastingTime] { return m_encapsulee.api.in.SetTime(toastingTime); });
    };
    m_ppApi.in.GetTime = [&](size_t& toastingTime) {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.GetTime(toastingTime); });
    };
    m_ppApi.in.Toast = [&](std::string motd, std::shared_ptr<ResultInfo>& info) {
        return dzn::shell(m_dispatcher, [&, motd] { return m_encapsulee.api.in.Toast(motd, info); });
    };
    m_ppApi.in.Cancel = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Cancel(); });
    };
    m_ppApi.in.Recover = [&] {
        return dzn::shell(m_dispatcher, [&] { return m_encapsulee.api.in.Recover(); });
    };

    // Reference out-events of boundary provides ports (MTS) to the respective ports of the encapsulee
    m_encapsulee.api.out.Ok = std::ref(m_ppApi.out.Ok);
    m_encapsulee.api.out.Fail = std::ref(m_ppApi.out.Fail);
    m_encapsulee.api.out.Error = std::ref(m_ppApi.out.Error);

    // Boundary requires ports (MTS) initialization:
    // ---------------------------------------------

    // <None>
}

void DummyToasterAdvShell::FinalConstruct(const dzn::meta* parentComponentMeta)
{
    // Check the bindings of all boundary ports
    m_ppApi.check_bindings();

    // Complete the encapsulated component meta information and check the bindings of all encapsulee ports
    m_encapsulee.dzn_meta.parent = parentComponentMeta;
    m_encapsulee.check_bindings();
}

dzn::locator& DummyToasterAdvShell::Locator()
{
    return m_locator;
}

::Dzn::Mts<::My::Project::IToaster> DummyToasterAdvShell::ProvidesApi()
{
    return {m_ppApi};
}

} // namespace My
// Generated by: dznpy/adv_shell v1.2.DEV
'''
